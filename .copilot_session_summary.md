# Copilot Session Summary

## Last Updated
2025-11-28 - Performance and Memory Optimization Session 7 ✅

## Completed Tasks

### Session 7: Additional Pre-Roslyn Compilation Optimizations (Current)

#### Issues Identified & Fixed:

**1. MethodNameNormalizer.Normalize() String Allocations** - FIXED
- Called 3 times per method resolution (TryGetRawMethod, TryGetAnnotatedMethod, RegisterMethod)
- Created 2 new strings per call: `ToLowerInvariant()` + `Replace("_", "")`
- **Fix**: Added `ConcurrentDictionary<string, string>` cache with fast-path for already normalized names
- **Impact**: For 30K+ method resolutions × 3 calls = 90K+ string allocations → cached to ~1K

**2. Lock Contention in StringHelpers.GenerateNamespaceIdentifier()** - FIXED
- Used `lock` statement for simple counter increment
- In parallel test runs (24 cores), this caused contention
- **Fix**: Replaced with `Interlocked.Increment()` - lock-free atomic operation

**3. Method Resolution Sorting Allocations** - FIXED
- `OrderBy(MeasureHowCloseTheMethodIsAgainstTheArguments).ToList()` created new List every call
- Called for every method resolution
- **Fix**: Use stack-allocated `Span<(int Score, int Index)>` for small method counts (≤32), regular array for larger
- **Additional**: Eliminated second sorting in tie-breaking case (methods already sorted)
- **Impact**: Eliminated 30K+ List<MethodInfo> allocations per test run

**4. LINQ Allocations in ResolveMethod()** - FIXED
- `args.Args.Select(f => f.ReturnType).ToArray()` called 3 times per method resolution
- Created new arrays + iterator objects
- **Fix**: Pre-compute argTypes array once and reuse
- **Impact**: 90K+ LINQ allocations → 30K simple array allocations

#### Files Modified This Session:
- `Musoq.Schema/Helpers/MethodNameNormalizer.cs` - Added caching with fast-path
- `Musoq.Evaluator/Helpers/StringHelpers.cs` - Replaced lock with Interlocked
- `Musoq.Schema/Managers/MethodsMetadata.cs` - Stack-allocated sorting, eliminated ToList()
- `Musoq.Evaluator/Visitors/BuildMetadataAndInferTypesVisitor.cs` - Pre-computed arg types

---

### Session 6: Critical Method Resolution Optimization (Previous)

#### Issue Identified & Fixed:

**GetParameters() Reflection Overhead in Method Resolution** - FIXED

**Why this is critical:**
- `MethodsMetadata.TryGetAnnotatedMethodByExactName()` is called for EVERY function call in every query
- Inside this method, `OrderBy(MeasureHowCloseTheMethodIsAgainstTheArguments)` sorts methods
- The comparison function calls `GetParameters()` on each MethodInfo
- With N overloads, sorting requires O(N log N) comparisons, each calling `GetParameters()`
- Plus another `GetParameters()` call per method in the main matching loop
- For 3000+ tests with ~10 method calls each = 30,000+ method resolutions
- Common functions have 10-50+ overloads (Sum, Count, ToString, etc.)

**The Fix:**
Added `Dictionary<MethodInfo, ParameterInfo[]> _parametersCache` and `GetCachedParameters()` method to cache `GetParameters()` results.

**File Modified:**
- `Musoq.Schema/Managers/MethodsMetadata.cs`:
  - Added `_parametersCache` dictionary
  - Added `GetCachedParameters(MethodInfo)` method
  - Updated 5 call sites to use cached parameters:
    - `TryGetRawMethodByExactName()` main loop
    - `TryGetAnnotatedMethodByExactName()` main loop
    - `MeasureHowCloseTheMethodIsAgainstTheArguments()` - most critical (called N log N times during sort)
    - `GetInjectTypeAttribute()` 
    - `GetAvailableMethodSignatures()`

**Performance Impact:**
- Before: `GetParameters()` called ~(N log N + N) times per method resolution where N = overload count
- After: `GetParameters()` called at most once per unique MethodInfo (then cached)
- For 30,000 resolutions × 20 avg overloads × (20 log 20 + 20) ≈ 50M reflection calls → ~60K (first-time caching)

---

### Session 5: Additional Evaluator Optimizations (Previous)

#### Issues Identified & Fixed:

1. **EvaluationHelper.GetCastableType repeated string computations** - FIXED
   - Called 20+ times per query during code generation
   - For non-primitive types, repeatedly computed string representation
   - **Fix**: Added `ConcurrentDictionary<Type, string>` cache for complex types

2. **SyntaxFactory.ParseTypeName called repeatedly with same strings** - FIXED
   - Common types like "ObjectsRow", "object", "Row" parsed every time
   - Roslyn parsing is expensive for repeated identical strings
   - **Fix**: Created `SyntaxHelper.GetCachedTypeSyntax()` with ConcurrentDictionary
   - **Additional**: Pre-cached static TypeSyntax fields for most common types:
     - `ObjectTypeSyntax`, `RowTypeSyntax`, `ObjectsRowTypeSyntax`
     - `IndexOutOfRangeExceptionTypeSyntax`, `IObjectResolverTypeSyntax`
     - `RowConcreteTypeSyntax`, `ListOfIObjectResolverTypeSyntax`
     - `ObjectArrayTypeSyntax` (pre-built ArrayTypeSyntax for object[])

#### Files Modified This Session:
- `Musoq.Evaluator/Helpers/EvaluationHelper.cs` - Added CastableTypeCache
- `Musoq.Evaluator/Helpers/SyntaxHelper.cs` - Added TypeSyntax caching
- `Musoq.Evaluator/Visitors/ToCSharpRewriteTreeVisitor.cs` - Uses cached types
- `Musoq.Evaluator/Visitors/Helpers/JoinSourcesTableProcessingHelper.cs` - Uses cached types
- `Musoq.Evaluator/Visitors/Helpers/JoinProcessingHelper.cs` - Uses cached types
- `Musoq.Evaluator/Visitors/Helpers/SelectNodeProcessor.cs` - Uses cached types
- `Musoq.Evaluator/Visitors/Helpers/ApplyInMemoryWithSourceTableNodeProcessor.cs` - Uses cached types

---

### Session 4: Performance & Memory Optimization (Previous)

#### Issues Identified & Fixed:

1. **Lexer Token Definitions (60+ Regex per query)** - FIXED
   - `DefinitionSets.General` used expression-bodied property (`=>`) creating NEW TokenDefinition array with NEW Regex objects on EVERY Lexer instantiation
   - ~60 Regex patterns × 3000+ tests = 180,000+ unnecessary Regex creations
   - **Fix**: Changed to static readonly field (`{ get; } = [...]`) so it's created once
   - **Additional**: Added `RegexOptions.Compiled` to all token definitions

2. **MetadataReference.CreateFromFile called per query** - FIXED
   - Created new MetadataReference objects from files on every compilation
   - Same assemblies loaded repeatedly across tests
   - **Fix**: Created `MetadataReferenceCache` with `ConcurrentDictionary` to cache references

3. **AdhocWorkspace and SyntaxGenerator created per query** - FIXED
   - Heavy Roslyn workspace creation for each compilation
   - **Fix**: Created `RoslynSharedFactory` with thread-local storage for reused Workspace and SyntaxGenerator

4. **NonDeterministicMethodsScanner scans assemblies per query** - FIXED
   - Reflection-based assembly scanning happened on every query
   - **Fix**: Added `ConcurrentDictionary` cache for assembly scan results

5. **RuntimeLibraries parallel loading simplified** - FIXED
   - Used `Task.WaitAll` for parallel loading, now uses sequential with cache

6. **Additional Regex allocations in Lexer.GetTokenCandidate** - FIXED
   - Created new Regex for hex, binary, octal, signed, unsigned integers per token check
   - **Fix**: Made static compiled Regex fields for all numeric literal patterns

7. **Parser.ConsumeAsColumn Regex allocation** - FIXED
   - Created new Regex each time a column token was consumed
   - **Fix**: Made static compiled Regex field

8. **List pre-allocation for common sizes** - FIXED
   - `_loadedAssemblies` and `_namespaces` in ToCSharpRewriteTreeVisitor
   - `Assemblies` in BuildMetadataAndInferTypesVisitor
   - **Fix**: Pre-allocated with typical sizes (8, 16, 20) to avoid resizing

#### Files Created:
- `Musoq.Evaluator/Runtime/MetadataReferenceCache.cs` - Thread-safe cache for MetadataReference
- `Musoq.Evaluator/Runtime/RoslynSharedFactory.cs` - Thread-local Workspace/Generator sharing

#### Files Modified:
- `Musoq.Parser/Lexing/Lexer.cs` - Static token definitions + static numeric Regex patterns
- `Musoq.Parser/Lexing/LexerBase.cs` - Added RegexOptions.Compiled
- `Musoq.Parser/Parser.cs` - Static column Regex
- `Musoq.Evaluator/Visitors/ToCSharpRewriteTreeVisitor.cs` - Uses shared factory + pre-allocated lists
- `Musoq.Evaluator/Visitors/BuildMetadataAndInferTypesVisitor.cs` - Pre-allocated Assemblies list
- `Musoq.Evaluator/Runtime/RuntimeLibraries.cs` - Uses MetadataReferenceCache
- `Musoq.Evaluator/Helpers/NonDeterministicMethodsScanner.cs` - Assembly scan caching

#### Expected Improvements:
- **Memory**: 60+ fewer Regex objects per query, shared MetadataReferences, thread-local reuse
- **Speed**: Eliminated Regex constructor calls, shared workspace, cached references
- **For 3000+ tests**: Previously 180,000+ Regex objects → Now 60 (shared)

---

### Session 3: CSE Implementation (Previous)
- ✅ Created design document: `docs/design/common-subexpression-elimination.md`
- ✅ Created 18 unit tests: `Musoq.Evaluator.Tests/CommonSubexpressionEliminationTests.cs`
- ✅ Created benchmarks: `Musoq.Benchmarks/CommonSubexpressionEliminationBenchmark.cs`
- ✅ Established baseline performance metrics

### Session 2: CSE Implementation
- ✅ Created `CommonSubexpressionAnalysisVisitor.cs` - Analyzes expressions for cacheability
- ✅ Created `CommonSubexpressionAnalysisTraverseVisitor.cs` - Tree traversal for CSE analysis
- ✅ Modified `ToCSharpRewriteTreeVisitor.cs` - Added CSE code generation with local variables
- ✅ Modified `TransformTree.cs` - Integrated CSE analysis phase
- ✅ All 18 CSE unit tests passing
- ✅ Full test suite passing (1719 tests, 7 skipped, 0 failures)
- ✅ Benchmark comparison complete - CSE working as expected!

## Current Status
- **Build status**: ✅ Success
- **Test status**: ✅ 3094 pass, 7 skipped, 0 failures
- **Known issues**: None

## Cumulative Optimization Summary

### Memory Allocation Reductions
| Area | Before | After |
|------|--------|-------|
| Lexer Token Regex | 60+ per query | 1 shared static array |
| Numeric Pattern Regex | 5 per token | 5 static compiled |
| MetadataReference | New per assembly | Cached in ConcurrentDictionary |
| AdhocWorkspace | New per query | ThreadLocal reuse |
| SyntaxGenerator | New per query | ThreadLocal reuse |
| MethodInfo reflection | Per method call | Static readonly fields |
| GetCastableType strings | Computed per call | Cached for complex types |
| ParseTypeName | Parsed per call | Cached in ConcurrentDictionary |
| Common TypeSyntax | Created per use | Pre-cached static fields |

### Key Patterns Used
- **ConcurrentDictionary**: Thread-safe caching for MetadataReference, TypeSyntax, assembly scanning, type strings
- **ThreadLocal**: Per-thread reuse of AdhocWorkspace/SyntaxGenerator
- **Static readonly**: One-time initialization for Regex, MethodInfo, common TypeSyntax
- **Pre-allocation**: Initial capacity hints for Lists and Dictionaries

## Benchmark Results Comparison

### Before CSE (Baseline)
| Method | 10K Rows | 100K Rows | Ratio |
|--------|----------|-----------|-------|
| Query_NoDuplicates | 4.97 ms | 49.40 ms | 1.00 |
| Query_DuplicateInWhereAndSelect (2x) | 7.32 ms | 73.60 ms | 1.47-1.49 |
| Query_TripleDuplicates (3x) | 10.21 ms | 100.00 ms | 2.02-2.05 |
| Query_NestedDuplicates (4x) | 13.28 ms | 127.74 ms | 2.59-2.67 |

### After CSE Implementation
| Method | 10K Rows | 100K Rows | Ratio |
|--------|----------|-----------|-------|
| Query_NoDuplicates | 4.90 ms | 51.55 ms | 1.00 |
| Query_DuplicateInWhereAndSelect (2x) | 5.33 ms | 51.39 ms | **1.09 / 1.00** |
| Query_TripleDuplicates (3x) | 4.59 ms | 51.95 ms | **0.94 / 1.01** |
| Query_NestedDuplicates (4x) | 5.03 ms | 52.24 ms | **1.03 / 1.01** |

### Performance Improvements
- **2x duplicate expressions**: ~27-30% faster
- **3x duplicate expressions**: ~48-55% faster
- **4x nested duplicates**: ~59-62% faster
- **No regression** in baseline (no duplicates) case

## Implementation Details

### Approach
- Using local variable caching approach (per user preference)
- CSE variables are named `_cse0`, `_cse1`, etc.
- First occurrence uses assignment expression: `(_cse0 = ExpensiveMethod(x))`
- Subsequent occurrences use variable reference: `_cse0`

### Non-Cacheable Expressions
- Non-deterministic functions (RANDOM, NOW, NEWID, GUID)
- Simple literals
- Column access (cheap enough not worth caching)
- Expressions appearing in unsafe contexts (ORDER BY, GROUP BY, HAVING, CASE WHEN)

**Note**: Aggregate functions (SUM, COUNT, MIN, MAX, AVG) ARE cacheable since Session 3 refactoring.

### Generated Code Pattern
```csharp
foreach (var score in source.Rows)
{
    // CSE variable declarations (inserted at start)
    int _cse0 = default;
    string _cse1 = default;
    
    // WHERE clause (first occurrence assigns)
    if (!(_cse0 = ExpensiveMethod(x)) > 5) continue;
    
    // SELECT clause (uses cached value)
    row[0] = _cse0;  // reuses cached value
}
```

## Files Created
1. `docs/design/common-subexpression-elimination.md` - Design document
2. `Musoq.Evaluator.Tests/CommonSubexpressionEliminationTests.cs` - 18 unit tests
3. `Musoq.Benchmarks/CommonSubexpressionEliminationBenchmark.cs` - Benchmark tests
4. `Musoq.Evaluator/Visitors/CommonSubexpressionAnalysisVisitor.cs` - CSE analysis
5. `Musoq.Evaluator/Visitors/CommonSubexpressionAnalysisTraverseVisitor.cs` - Tree traversal

## Files Modified
1. `Musoq.Evaluator/Visitors/ToCSharpRewriteTreeVisitor.cs` - CSE code generation
2. `Musoq.Converter/Build/TransformTree.cs` - Pipeline integration
3. `Musoq.Evaluator/Visitors/IToCSharpTranslationExpressionVisitor.cs` - Added InitializeCseForQuery interface
4. `Musoq.Evaluator/Visitors/ToCSharpRewriteTreeTraverseVisitor.cs` - Per-query CSE initialization

## Session 3 Changes Summary

### Per-Query CSE Architecture
CSE analysis now runs separately for each query/subquery/CTE via `InitializeCseForQuery()`.
This ensures CSE variables don't leak between queries.

### Unsafe Context Handling
`InUnsafeCseContext` flag marks expressions in ORDER BY, GROUP BY, HAVING, CASE WHEN as non-cacheable.
These clauses generate code in scopes where CSE variables aren't accessible.

### Aggregate Functions Now Cacheable
`Sum(Value)`, `Count(*)`, `Avg(X)` are cacheable within a query - they return the same computed value.

## Remaining Considerations
- CSE works correctly for SELECT and WHERE clauses
- Expressions appearing in unsafe contexts are properly excluded
- Full test suite (1719 tests) passing
