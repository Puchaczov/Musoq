#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Musoq.Parser.Nodes;
using Musoq.Parser.Nodes.InterpretationSchema;

namespace Musoq.Evaluator.Visitors;

/// <summary>
///     Generates C# interpreter classes from binary and text schema AST nodes.
///     The generated classes inherit from BytesInterpreterBase or TextInterpreterBase
///     and implement the actual parsing logic.
/// </summary>
public class InterpreterCodeGenerator
{
    private readonly Dictionary<string, string> _generatedCode = new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    ///     Tracks inline schema definitions that need nested class generation.
    ///     Key is the field name prefix (e.g., "Header"), value is the inline schema node.
    /// </summary>
    private readonly List<(string ClassName, InlineSchemaTypeNode Schema, string? ParentFieldPrefix)> _inlineSchemas =
        new();

    private readonly SchemaRegistry _registry;
    private string[] _currentTypeParameters = Array.Empty<string>();

    /// <summary>
    ///     Creates a new interpreter code generator.
    /// </summary>
    /// <param name="registry">The schema registry containing schema definitions.</param>
    public InterpreterCodeGenerator(SchemaRegistry registry)
    {
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
    }

    /// <summary>
    ///     Gets the generated source code for all schemas.
    ///     Key is schema name, value is the C# source code.
    /// </summary>
    public IReadOnlyDictionary<string, string> GeneratedCode => _generatedCode;

    /// <summary>
    ///     Generates C# code for all schemas in the registry.
    /// </summary>
    /// <param name="namespaceName">The namespace for the generated classes.</param>
    /// <returns>Complete C# source code containing all generated interpreter classes.</returns>
    public string GenerateAll(string namespaceName = "Musoq.Generated.Interpreters")
    {
        var builder = new StringBuilder();


        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("// This code was generated by Musoq Interpretation Schema code generator.");
        builder.AppendLine("// Do not modify this file directly.");
        builder.AppendLine("// </auto-generated>");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Buffers.Binary;");
        builder.AppendLine("using Musoq.Schema.Interpreters;");
        builder.AppendLine();
        builder.AppendLine($"namespace {namespaceName}");
        builder.AppendLine("{");

        foreach (var registration in _registry.Schemas)
            if (registration.Node is BinarySchemaNode binarySchema)
            {
                var classCode = GenerateBinaryInterpreterClass(binarySchema);
                _generatedCode[registration.Name] = classCode;
                builder.AppendLine(Indent(classCode, 1));
                builder.AppendLine();
            }
            else if (registration.Node is TextSchemaNode textSchema)
            {
                var classCode = GenerateTextInterpreterClass(textSchema);
                _generatedCode[registration.Name] = classCode;
                builder.AppendLine(Indent(classCode, 1));
                builder.AppendLine();
            }

        builder.AppendLine("}");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates C# code for a single binary schema.
    /// </summary>
    private string GenerateBinaryInterpreterClass(BinarySchemaNode schema)
    {
        var builder = new StringBuilder();
        var className = schema.Name;


        _inlineSchemas.Clear();


        _currentTypeParameters = schema.TypeParameters ?? Array.Empty<string>();


        var typeParamsDecl = schema.IsGeneric
            ? $"<{string.Join(", ", schema.TypeParameters)}>"
            : string.Empty;
        var fullClassName = $"{className}{typeParamsDecl}";


        var genericConstraints = string.Empty;
        if (schema.IsGeneric)
        {
            var constraints = schema.TypeParameters
                .Select(t => $"where {t} : IBytesInterpreter<{t}>, new()")
                .ToArray();
            genericConstraints = " " + string.Join(" ", constraints);
        }


        var allFields = GetAllFieldsIncludingInherited(schema);


        builder.AppendLine("/// <summary>");
        builder.AppendLine($"/// Generated interpreter for binary schema '{className}'.");
        if (schema.IsGeneric)
            builder.AppendLine(
                $"/// This is a generic schema with type parameters: {string.Join(", ", schema.TypeParameters)}.");
        if (!string.IsNullOrEmpty(schema.Extends)) builder.AppendLine($"/// Extends schema '{schema.Extends}'.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine(
            $"public sealed class {fullClassName} : BytesInterpreterBase<{fullClassName}>{genericConstraints}");
        builder.AppendLine("{");


        foreach (var field in allFields)
        {
            if (field.Name == "_") continue;


            if (field is FieldDefinitionNode { TypeAnnotation: AlignmentNode }) continue;

            var clrTypeName = GetClrTypeNameForFieldWithContext(field, allFields);
            var isConditional = field.IsConditional;
            var isTypeParam = IsTypeParameter(clrTypeName);


            var propertyTypeName = isConditional && !IsReferenceType(clrTypeName) && !isTypeParam
                ? $"{clrTypeName}?"
                : clrTypeName;

            builder.AppendLine($"    /// <summary>Gets the {field.Name} field value.</summary>");
            builder.AppendLine($"    public {propertyTypeName} {field.Name} {{ get; init; }}");
            builder.AppendLine();
        }


        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override string SchemaName => \"{className}\";");
        builder.AppendLine();


        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override {fullClassName} InterpretAt(ReadOnlySpan<byte> data, int offset)");
        builder.AppendLine("    {");
        builder.AppendLine("        _parsePosition = offset;");
        builder.AppendLine("        BitOffset = 0;");
        builder.AppendLine();


        var fieldInitializers = new List<string>();
        foreach (var field in allFields)
            switch (field)
            {
                case FieldDefinitionNode parsedField:
                {
                    var readCode = GenerateFieldReadCodeWithModifiers(parsedField);
                    builder.Append(Indent(readCode, 2));

                    if (parsedField.Name != "_" && parsedField.TypeAnnotation is not AlignmentNode)
                        fieldInitializers.Add($"{parsedField.Name} = {GetLocalVarName(parsedField.Name)}");
                    break;
                }
                case ComputedFieldNode computedField:
                {
                    var computeCode = GenerateComputedFieldCode(computedField, allFields);
                    builder.Append(Indent(computeCode, 2));

                    if (computedField.Name != "_")
                        fieldInitializers.Add($"{computedField.Name} = {GetLocalVarName(computedField.Name)}");
                    break;
                }
            }


        builder.AppendLine($"        return new {fullClassName}");
        builder.AppendLine("        {");
        for (var i = 0; i < fieldInitializers.Count; i++)
        {
            var comma = i < fieldInitializers.Count - 1 ? "," : "";
            builder.AppendLine($"            {fieldInitializers[i]}{comma}");
        }

        builder.AppendLine("        };");
        builder.AppendLine("    }");


        foreach (var (inlineClassName, inlineSchema, _) in _inlineSchemas)
        {
            builder.AppendLine();
            var nestedClassCode = GenerateInlineSchemaNestedClass(inlineClassName, inlineSchema);
            builder.Append(Indent(nestedClassCode, 1));
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates a nested class for an inline schema.
    /// </summary>
    private string GenerateInlineSchemaNestedClass(string className, InlineSchemaTypeNode inlineSchema)
    {
        var builder = new StringBuilder();

        builder.AppendLine("/// <summary>");
        builder.AppendLine($"/// Generated nested interpreter for inline schema '{className}'.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine($"public sealed class {className} : BytesInterpreterBase<{className}>");
        builder.AppendLine("{");


        var fields = inlineSchema.Fields;
        foreach (var field in fields)
        {
            if (field.Name == "_") continue;

            if (field is FieldDefinitionNode { TypeAnnotation: AlignmentNode }) continue;

            var clrTypeName = GetClrTypeNameForFieldInline(field);
            var isConditional = field.IsConditional;
            var isTypeParam = IsTypeParameter(clrTypeName);

            var propertyTypeName = isConditional && !IsReferenceType(clrTypeName) && !isTypeParam
                ? $"{clrTypeName}?"
                : clrTypeName;

            builder.AppendLine($"    /// <summary>Gets the {field.Name} field value.</summary>");
            builder.AppendLine($"    public {propertyTypeName} {field.Name} {{ get; init; }}");
            builder.AppendLine();
        }


        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override string SchemaName => \"{className}\";");
        builder.AppendLine();


        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override {className} InterpretAt(ReadOnlySpan<byte> data, int offset)");
        builder.AppendLine("    {");
        builder.AppendLine("        _parsePosition = offset;");
        builder.AppendLine("        BitOffset = 0;");
        builder.AppendLine();


        var fieldInitializers = new List<string>();
        foreach (var field in fields)
        {
            if (field is not FieldDefinitionNode parsedField) continue;

            var readCode = GenerateFieldReadCodeWithModifiers(parsedField);
            builder.Append(Indent(readCode, 2));

            if (parsedField.Name != "_" && parsedField.TypeAnnotation is not AlignmentNode)
                fieldInitializers.Add($"{parsedField.Name} = {GetLocalVarName(parsedField.Name)}");
        }


        builder.AppendLine($"        return new {className}");
        builder.AppendLine("        {");
        for (var i = 0; i < fieldInitializers.Count; i++)
        {
            var comma = i < fieldInitializers.Count - 1 ? "," : "";
            builder.AppendLine($"            {fieldInitializers[i]}{comma}");
        }

        builder.AppendLine("        };");
        builder.AppendLine("    }");

        builder.AppendLine("}");

        return builder.ToString();
    }

    /// <summary>
    ///     Gets the CLR type name for a field in an inline schema context.
    /// </summary>
    private string GetClrTypeNameForFieldInline(SchemaFieldNode field)
    {
        return field switch
        {
            FieldDefinitionNode parsedField when parsedField.TypeAnnotation is InlineSchemaTypeNode nestedInline
                => GetOrRegisterInlineSchemaClassName(parsedField.Name, nestedInline, null),
            FieldDefinitionNode parsedField => GetClrTypeName(parsedField.TypeAnnotation),
            ComputedFieldNode computedField => InferComputedFieldTypeNameStatic(computedField.Expression),
            _ => "object"
        };
    }

    /// <summary>
    ///     Gets all fields for a schema, including inherited fields from parent schemas.
    ///     Parent fields come first, followed by child fields.
    /// </summary>
    private List<SchemaFieldNode> GetAllFieldsIncludingInherited(BinarySchemaNode schema)
    {
        var allFields = new List<SchemaFieldNode>();


        if (!string.IsNullOrEmpty(schema.Extends))
        {
            var parentSchema = _registry.Schemas
                .FirstOrDefault(s => s.Name.Equals(schema.Extends, StringComparison.OrdinalIgnoreCase));

            if (parentSchema?.Node is BinarySchemaNode parentBinarySchema)
                allFields.AddRange(GetAllFieldsIncludingInherited(parentBinarySchema));
        }


        allFields.AddRange(schema.Fields);

        return allFields;
    }

    /// <summary>
    ///     Generates field read code with support for at positioning, when conditions, and check constraints.
    /// </summary>
    private string GenerateFieldReadCodeWithModifiers(FieldDefinitionNode field)
    {
        var builder = new StringBuilder();
        var localVar = GetLocalVarName(field.Name);
        var clrTypeName = GetClrTypeNameForFieldDefinition(field);


        if (field.WhenCondition != null)
        {
            var condition = GenerateConditionExpression(field.WhenCondition);
            var isTypeParam = IsTypeParameter(clrTypeName);
            var isReferenceType = IsReferenceType(clrTypeName);


            string nullableTypeName;
            string defaultValue;

            if (isTypeParam)
            {
                nullableTypeName = clrTypeName;
                defaultValue = "default!";
            }
            else if (isReferenceType)
            {
                nullableTypeName = clrTypeName;
                defaultValue = "null";
            }
            else
            {
                nullableTypeName = $"{clrTypeName}?";
                defaultValue = "null";
            }


            builder.AppendLine($"{nullableTypeName} {localVar} = {defaultValue};");
            builder.AppendLine($"if ({condition})");
            builder.AppendLine("{");


            if (field.AtOffset != null)
            {
                var offsetExpr = GenerateConditionExpression(field.AtOffset);
                builder.AppendLine($"    _parsePosition = {offsetExpr};");
            }


            var innerReadCode = GenerateFieldReadCodeInner(field);
            builder.Append(Indent(innerReadCode, 1));


            if (field.Constraint != null)
            {
                var checkExpr = GenerateConditionExpression(field.Constraint.Expression);
                builder.AppendLine($"    Validate({checkExpr}, \"{field.Name}\", \"Check constraint failed\");");
            }

            builder.AppendLine("}");
        }
        else
        {
            if (field.AtOffset != null)
            {
                var offsetExpr = GenerateConditionExpression(field.AtOffset);
                builder.AppendLine($"_parsePosition = {offsetExpr};");
            }


            builder.AppendLine(GenerateFieldReadCode(field));


            if (field.Constraint != null)
            {
                var checkExpr = GenerateConditionExpression(field.Constraint.Expression);
                builder.AppendLine($"Validate({checkExpr}, \"{field.Name}\", \"Check constraint failed\");");
            }
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Generates the inner field read code (for use inside if blocks for conditional fields).
    ///     This generates only the assignment, not the variable declaration.
    /// </summary>
    private string GenerateFieldReadCodeInner(FieldDefinitionNode field)
    {
        var builder = new StringBuilder();
        var localVar = GetLocalVarName(field.Name);
        var typeAnnotation = field.TypeAnnotation;

        switch (typeAnnotation)
        {
            case PrimitiveTypeNode primitiveType:
                builder.AppendLine($"{localVar} = {GetPrimitiveReadMethod(primitiveType)}(data);");
                break;

            case ByteArrayTypeNode byteArrayType:
                var byteSize = GenerateSizeExpression(byteArrayType.SizeExpression);
                builder.AppendLine($"{localVar} = ReadBytes(data, {byteSize});");
                break;

            case StringTypeNode stringType:
                var strSize = GenerateSizeExpression(stringType.SizeExpression);
                var encodingExpr = GetEncodingExpression(stringType.Encoding);


                if (stringType.AsTextSchemaName != null)
                {
                    var rawStringVar = $"{localVar}_raw";
                    if (stringType.Modifiers.HasFlag(StringModifier.NullTerm))
                        builder.Append(
                            $"var {rawStringVar} = ReadNullTerminatedString(data, {strSize}, {encodingExpr})");
                    else
                        builder.Append($"var {rawStringVar} = ReadString(data, {strSize}, {encodingExpr})");


                    if (stringType.Modifiers.HasFlag(StringModifier.Trim))
                        builder.Append(".Trim()");
                    else if (stringType.Modifiers.HasFlag(StringModifier.LTrim))
                        builder.Append(".TrimStart()");
                    else if (stringType.Modifiers.HasFlag(StringModifier.RTrim))
                        builder.Append(".TrimEnd()");

                    builder.AppendLine(";");
                    builder.AppendLine($"var {localVar}_textInterpreter = new {stringType.AsTextSchemaName}();");
                    builder.AppendLine($"{localVar} = {localVar}_textInterpreter.Parse({rawStringVar});");
                }
                else
                {
                    if (stringType.Modifiers.HasFlag(StringModifier.NullTerm))
                        builder.Append($"{localVar} = ReadNullTerminatedString(data, {strSize}, {encodingExpr})");
                    else
                        builder.Append($"{localVar} = ReadString(data, {strSize}, {encodingExpr})");


                    if (stringType.Modifiers.HasFlag(StringModifier.Trim))
                        builder.Append(".Trim()");
                    else if (stringType.Modifiers.HasFlag(StringModifier.LTrim))
                        builder.Append(".TrimStart()");
                    else if (stringType.Modifiers.HasFlag(StringModifier.RTrim))
                        builder.Append(".TrimEnd()");

                    builder.AppendLine(";");
                }

                break;

            case BitsTypeNode bitsType:
                var innerBitCount = bitsType.BitCount;
                var innerBitClrType = innerBitCount switch
                {
                    <= 8 => "byte",
                    <= 16 => "ushort",
                    <= 32 => "uint",
                    _ => "ulong"
                };
                builder.AppendLine($"{localVar} = ({innerBitClrType})ReadBits(data, {innerBitCount});");
                break;

            case SchemaReferenceTypeNode schemaRef:
                builder.AppendLine($"var {localVar}_interpreter = new {schemaRef.SchemaName}();");
                builder.AppendLine($"{localVar} = {localVar}_interpreter.InterpretAt(data, _parsePosition);");
                builder.AppendLine($"_parsePosition = {localVar}_interpreter.BytesConsumed;");
                break;

            case ArrayTypeNode arrayType:
                var arraySizeExpr = GenerateSizeExpression(arrayType.SizeExpression);
                var elementTypeName = GetClrTypeName(arrayType.ElementType);
                builder.AppendLine($"{localVar} = new {elementTypeName}[{arraySizeExpr}];");
                builder.AppendLine($"for (int i = 0; i < {arraySizeExpr}; i++)");
                builder.AppendLine("{");

                if (arrayType.ElementType is PrimitiveTypeNode elemPrimitive)
                {
                    builder.AppendLine($"    {localVar}[i] = {GetPrimitiveReadMethod(elemPrimitive)}(data);");
                }
                else if (arrayType.ElementType is SchemaReferenceTypeNode elemSchemaRef)
                {
                    var elemSchemaName = elemSchemaRef.SchemaName;
                    builder.AppendLine($"    var _elem_interpreter = new {elemSchemaName}();");
                    builder.AppendLine($"    {localVar}[i] = _elem_interpreter.InterpretAt(data, _parsePosition);");
                    builder.AppendLine("    _parsePosition = _elem_interpreter.BytesConsumed;");
                }
                else
                {
                    builder.AppendLine(
                        $"    // TODO: Unsupported array element type: {arrayType.ElementType.GetType().Name}");
                }

                builder.AppendLine("}");
                break;

            case AlignmentNode alignmentNode:
                builder.AppendLine($"AlignToBits(data, {alignmentNode.AlignmentBits});");
                break;

            case InlineSchemaTypeNode inlineSchema:

                var inlineClassName = GetOrRegisterInlineSchemaClassName(field.Name, inlineSchema, null);
                builder.AppendLine($"var {localVar}_interpreter = new {inlineClassName}();");
                builder.AppendLine($"{localVar} = {localVar}_interpreter.InterpretAt(data, _parsePosition);");
                builder.AppendLine($"_parsePosition = {localVar}_interpreter.BytesConsumed;");
                break;

            default:
                builder.AppendLine($"// TODO: Unsupported type annotation: {typeAnnotation.GetType().Name}");
                if (field.Name != "_") builder.AppendLine($"{localVar} = default({GetClrTypeName(typeAnnotation)})!;");
                break;
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Generates C# code for a single text schema.
    /// </summary>
    private string GenerateTextInterpreterClass(TextSchemaNode schema)
    {
        var builder = new StringBuilder();
        var className = schema.Name;

        builder.AppendLine("/// <summary>");
        builder.AppendLine($"/// Generated interpreter for text schema '{className}'.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine($"public sealed class {className} : TextInterpreterBase<{className}>");
        builder.AppendLine("{");


        foreach (var field in schema.Fields)
        {
            if (field.IsDiscard) continue;
            builder.AppendLine($"    /// <summary>Gets the {field.Name} field value.</summary>");


            if (field.FieldType == TextFieldType.Repeat)
            {
                var schemaName = field.PrimaryValue ?? "object";
                builder.AppendLine($"    public {schemaName}[]? {field.Name} {{ get; init; }}");
            }

            else if (field.FieldType == TextFieldType.Switch)
            {
                builder.AppendLine($"    public object? {field.Name} {{ get; init; }}");
            }
            else
            {
                builder.AppendLine($"    public string? {field.Name} {{ get; init; }}");
            }

            builder.AppendLine();
        }

        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override string SchemaName => \"{className}\";");
        builder.AppendLine();

        builder.AppendLine("    /// <inheritdoc />");
        builder.AppendLine($"    public override {className} ParseAt(ReadOnlySpan<char> data, int offset)");
        builder.AppendLine("    {");
        builder.AppendLine("        _parsePosition = offset;");
        builder.AppendLine();


        var fieldInitializers = new List<string>();
        var fieldsList = schema.Fields.ToList();
        for (var i = 0; i < fieldsList.Count; i++)
        {
            var field = fieldsList[i];
            var nextField = i < fieldsList.Count - 1 ? fieldsList[i + 1] : null;
            var readCode = GenerateTextFieldReadCode(field, nextField);
            builder.Append(Indent(readCode, 2));

            if (!field.IsDiscard) fieldInitializers.Add($"{field.Name} = {GetLocalVarName(field.Name)}");
        }


        builder.AppendLine($"        return new {className}");
        builder.AppendLine("        {");
        for (var i = 0; i < fieldInitializers.Count; i++)
        {
            var comma = i < fieldInitializers.Count - 1 ? "," : "";
            builder.AppendLine($"            {fieldInitializers[i]}{comma}");
        }

        builder.AppendLine("        };");
        builder.AppendLine("    }");

        builder.AppendLine("}");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates the code to read a single text field.
    /// </summary>
    private string GenerateTextFieldReadCode(TextFieldDefinitionNode field, TextFieldDefinitionNode? nextField)
    {
        var builder = new StringBuilder();
        var localVar = GetLocalVarName(field.Name);
        var isDiscard = field.IsDiscard;
        var isOptional = (field.Modifiers & TextFieldModifier.Optional) != 0;


        if (isOptional && !isDiscard)
        {
            builder.AppendLine($"string? {localVar} = null;");
            builder.AppendLine($"var _savedPos_{localVar} = _parsePosition;");
            builder.AppendLine("try");
            builder.AppendLine("{");
            builder.Append("    ");
            builder.AppendLine(GenerateTextFieldReadCodeInner(field, $"_temp_{localVar}", false, nextField));
            builder.AppendLine($"    {localVar} = _temp_{localVar};");
            builder.AppendLine("}");
            builder.AppendLine("catch");
            builder.AppendLine("{");
            builder.AppendLine($"    _parsePosition = _savedPos_{localVar};");
            builder.AppendLine("}");
        }
        else if (isOptional && isDiscard)
        {
            var discardId = Guid.NewGuid().ToString("N")[..8];
            builder.AppendLine($"var _savedPos_{discardId} = _parsePosition;");
            builder.AppendLine("try");
            builder.AppendLine("{");
            builder.Append("    ");
            builder.AppendLine(GenerateTextFieldReadCodeInner(field, "_", true, nextField));
            builder.AppendLine("}");
            builder.AppendLine("catch");
            builder.AppendLine("{");
            builder.AppendLine($"    _parsePosition = _savedPos_{discardId};");
            builder.AppendLine("}");
        }
        else
        {
            builder.AppendLine(GenerateTextFieldReadCodeInner(field, localVar, isDiscard, nextField));
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Generates the inner code to read a text field (without optional wrapping).
    /// </summary>
    private string GenerateTextFieldReadCodeInner(TextFieldDefinitionNode field, string localVar, bool isDiscard,
        TextFieldDefinitionNode? nextField)
    {
        return field.FieldType switch
        {
            TextFieldType.Literal => GenerateLiteralCode(field),
            TextFieldType.Until => GenerateUntilCode(field, localVar, isDiscard, nextField),
            TextFieldType.Between => GenerateBetweenCode(field, localVar, isDiscard),
            TextFieldType.Chars => GenerateCharsCode(field, localVar, isDiscard),
            TextFieldType.Token => GenerateTokenCode(field, localVar, isDiscard),
            TextFieldType.Rest => GenerateRestCode(field, localVar, isDiscard),
            TextFieldType.Whitespace => GenerateWhitespaceCode(field),
            TextFieldType.Pattern => GeneratePatternCode(field, localVar, isDiscard),
            TextFieldType.Repeat => GenerateRepeatCode(field, localVar, isDiscard),
            TextFieldType.Switch => GenerateSwitchCode(field, localVar, isDiscard),
            _ => throw new NotSupportedException($"Text field type '{field.FieldType}' is not yet supported.")
        };
    }

    /// <summary>
    ///     Generates code for literal field matching.
    /// </summary>
    private string GenerateLiteralCode(TextFieldDefinitionNode field)
    {
        var escapedLiteral = EscapeCSharpString(field.PrimaryValue ?? string.Empty);
        return $"ExpectLiteral(data, \"{escapedLiteral}\");";
    }

    /// <summary>
    ///     Generates code for until-delimiter field capture.
    /// </summary>
    private string GenerateUntilCode(TextFieldDefinitionNode field, string localVar, bool isDiscard,
        TextFieldDefinitionNode? nextField)
    {
        var escapedDelimiter = EscapeCSharpString(field.PrimaryValue ?? string.Empty);
        var hasTrim = (field.Modifiers & TextFieldModifier.Trim) != 0;
        var trimArg = hasTrim ? ", trim: true" : "";


        var shouldNotConsume = nextField is { FieldType: TextFieldType.Between }
                               && string.Equals(field.PrimaryValue, nextField.PrimaryValue, StringComparison.Ordinal);
        var consumeArg = shouldNotConsume ? ", consumeDelimiter: false" : "";

        if (isDiscard) return $"_ = ReadUntil(data, \"{escapedDelimiter}\"{trimArg}{consumeArg});";
        return $"var {localVar} = ReadUntil(data, \"{escapedDelimiter}\"{trimArg}{consumeArg});";
    }

    /// <summary>
    ///     Generates code for between-delimiters field capture.
    /// </summary>
    private string GenerateBetweenCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var escapedOpen = EscapeCSharpString(field.PrimaryValue ?? string.Empty);
        var escapedClose = EscapeCSharpString(field.SecondaryValue ?? string.Empty);
        var nested = (field.Modifiers & TextFieldModifier.Nested) != 0 ? ", nested: true" : "";
        var hasTrim = (field.Modifiers & TextFieldModifier.Trim) != 0;
        var trimArg = hasTrim ? ", trim: true" : "";

        if (isDiscard) return $"_ = ReadBetween(data, \"{escapedOpen}\", \"{escapedClose}\"{nested}{trimArg});";
        return $"var {localVar} = ReadBetween(data, \"{escapedOpen}\", \"{escapedClose}\"{nested}{trimArg});";
    }

    /// <summary>
    ///     Generates code for fixed-width character capture.
    /// </summary>
    private string GenerateCharsCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var count = field.PrimaryValue ?? "0";
        var modArgs = GenerateModifierArgs(field.Modifiers);

        if (isDiscard) return $"_ = ReadChars(data, {count}{modArgs});";
        return $"var {localVar} = ReadChars(data, {count}{modArgs});";
    }

    /// <summary>
    ///     Generates code for token capture.
    /// </summary>
    private string GenerateTokenCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var hasTrim = (field.Modifiers & TextFieldModifier.Trim) != 0;
        var trimArg = hasTrim ? ", trim: true" : "";

        if (isDiscard) return $"_ = ReadToken(data{trimArg});";
        return $"var {localVar} = ReadToken(data{trimArg});";
    }

    /// <summary>
    ///     Generates code for rest-of-input capture.
    /// </summary>
    private string GenerateRestCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var modArgs = GenerateModifierArgs(field.Modifiers);

        if (isDiscard) return $"_ = ReadRest(data{modArgs});";
        return $"var {localVar} = ReadRest(data{modArgs});";
    }

    /// <summary>
    ///     Generates code for whitespace consumption with quantifier support.
    ///     Quantifiers: + = one or more (required), * = zero or more, ? = zero or one
    /// </summary>
    private string GenerateWhitespaceCode(TextFieldDefinitionNode field)
    {
        var quantifier = field.PrimaryValue ?? "+";

        return quantifier switch
        {
            "+" => "SkipWhitespace(data, true);",
            "*" => "SkipWhitespace(data, false);",
            "?" => "SkipOptionalWhitespace(data);",
            _ => "SkipWhitespace(data, true);"
        };
    }

    /// <summary>
    ///     Generates code for pattern matching.
    /// </summary>
    private string GeneratePatternCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var escapedPattern = EscapeCSharpString(field.PrimaryValue ?? string.Empty);

        if (isDiscard) return $"_ = ReadPattern(data, @\"{field.PrimaryValue ?? string.Empty}\");";
        return $"var {localVar} = ReadPattern(data, @\"{field.PrimaryValue ?? string.Empty}\");";
    }

    /// <summary>
    ///     Generates code for repeat field - parses a schema repeatedly until delimiter or end.
    /// </summary>
    private string GenerateRepeatCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var schemaName = field.PrimaryValue ??
                         throw new InvalidOperationException("Repeat field must specify a schema name");
        var untilDelimiter = field.SecondaryValue;

        var builder = new StringBuilder();
        var listVar = $"_list_{localVar}";
        var itemVar = $"_item_{localVar}";
        var interpreterVar = $"_interp_{schemaName}";


        builder.AppendLine($"var {listVar} = new System.Collections.Generic.List<{schemaName}>();");
        builder.AppendLine($"var {interpreterVar} = new {schemaName}();");

        if (untilDelimiter != null)
        {
            var escapedDelimiter = EscapeCSharpString(untilDelimiter);
            builder.AppendLine($"while (!IsAtEnd(data) && !LookaheadMatches(data, \"{escapedDelimiter}\"))");
            builder.AppendLine("{");
            builder.AppendLine($"    var {itemVar} = {interpreterVar}.ParseAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = {interpreterVar}.Position;");
            builder.AppendLine($"    {listVar}.Add({itemVar});");
            builder.AppendLine("}");

            builder.AppendLine($"if (LookaheadMatches(data, \"{escapedDelimiter}\"))");
            builder.AppendLine("{");
            builder.AppendLine($"    _parsePosition += {untilDelimiter.Length};");
            builder.AppendLine("}");
        }
        else
        {
            builder.AppendLine("while (!IsAtEnd(data))");
            builder.AppendLine("{");
            builder.AppendLine($"    var {itemVar} = {interpreterVar}.ParseAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = {interpreterVar}.Position;");
            builder.AppendLine($"    {listVar}.Add({itemVar});");
            builder.AppendLine("}");
        }


        if (isDiscard)
            builder.AppendLine($"_ = {listVar}.ToArray();");
        else
            builder.AppendLine($"var {localVar} = {listVar}.ToArray();");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates code for switch field - uses lookahead pattern matching to determine which schema to parse.
    /// </summary>
    private string GenerateSwitchCode(TextFieldDefinitionNode field, string localVar, bool isDiscard)
    {
        var builder = new StringBuilder();

        if (field.SwitchCases.Length == 0)
            throw new InvalidOperationException("Switch field must have at least one case");


        builder.AppendLine($"object? {localVar} = null;");

        var isFirstCase = true;
        TextSwitchCaseNode? defaultCase = null;

        foreach (var switchCase in field.SwitchCases)
        {
            if (switchCase.IsDefault)
            {
                defaultCase = switchCase;
                continue;
            }

            var escapedPattern = EscapeCSharpRegexString(switchCase.Pattern!);
            var schemaName = switchCase.TypeName;

            if (isFirstCase)
            {
                builder.AppendLine($"if (LookaheadMatchesPattern(data, @\"{escapedPattern}\"))");
                isFirstCase = false;
            }
            else
            {
                builder.AppendLine($"else if (LookaheadMatchesPattern(data, @\"{escapedPattern}\"))");
            }

            builder.AppendLine("{");
            builder.AppendLine($"    var _interp_{schemaName} = new {schemaName}();");
            builder.AppendLine($"    {localVar} = _interp_{schemaName}.ParseAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = _interp_{schemaName}.Position;");
            builder.AppendLine("}");
        }


        if (defaultCase != null)
        {
            var schemaName = defaultCase.TypeName;
            if (!isFirstCase) builder.AppendLine("else");
            builder.AppendLine("{");
            builder.AppendLine($"    var _interp_{schemaName} = new {schemaName}();");
            builder.AppendLine($"    {localVar} = _interp_{schemaName}.ParseAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = _interp_{schemaName}.Position;");
            builder.AppendLine("}");
        }
        else if (!isFirstCase)
        {
            builder.AppendLine("else");
            builder.AppendLine("{");
            builder.AppendLine(
                "    throw new System.InvalidOperationException(\"No switch case matched at position \" + _parsePosition);");
            builder.AppendLine("}");
        }


        if (isDiscard) builder.AppendLine($"_ = {localVar};");

        return builder.ToString();
    }

    /// <summary>
    ///     Escapes a string for use in C# verbatim string regex pattern.
    /// </summary>
    private static string EscapeCSharpRegexString(string value)
    {
        return value.Replace("\"", "\"\"");
    }

    /// <summary>
    ///     Escapes a string for use in C# string literal.
    /// </summary>
    private static string EscapeCSharpString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r", "\\r")
            .Replace("\n", "\\n")
            .Replace("\t", "\\t");
    }

    /// <summary>
    ///     Generates modifier arguments for text field read methods.
    /// </summary>
    private static string GenerateModifierArgs(TextFieldModifier modifiers)
    {
        var hasTrim = (modifiers & TextFieldModifier.Trim) != 0;
        var hasLTrim = (modifiers & TextFieldModifier.LTrim) != 0;
        var hasRTrim = (modifiers & TextFieldModifier.RTrim) != 0;


        if (hasTrim)
            return ", trim: true";


        var args = new List<string>();
        if (hasLTrim)
            args.Add("ltrim: true");
        if (hasRTrim)
            args.Add("rtrim: true");

        return args.Count > 0 ? ", " + string.Join(", ", args) : "";
    }

    /// <summary>
    ///     Generates the code to read a single field.
    /// </summary>
    private string GenerateFieldReadCode(FieldDefinitionNode field)
    {
        var builder = new StringBuilder();
        var localVar = GetLocalVarName(field.Name);
        var typeAnnotation = field.TypeAnnotation;

        switch (typeAnnotation)
        {
            case PrimitiveTypeNode primitiveType:
                builder.AppendLine(GeneratePrimitiveReadCode(localVar, primitiveType));
                break;

            case ByteArrayTypeNode byteArrayType:
                builder.AppendLine(GenerateByteArrayReadCode(localVar, byteArrayType));
                break;

            case StringTypeNode stringType:
                builder.AppendLine(GenerateStringReadCode(localVar, stringType));
                break;

            case BitsTypeNode bitsType:
                builder.AppendLine(GenerateBitsReadCode(localVar, bitsType));
                break;

            case SchemaReferenceTypeNode schemaRef:
                builder.AppendLine(GenerateSchemaReferenceReadCode(localVar, schemaRef));
                break;

            case ArrayTypeNode arrayType:
                builder.AppendLine(GenerateArrayReadCode(localVar, arrayType));
                break;

            case RepeatUntilTypeNode repeatUntilType:
                builder.AppendLine(GenerateRepeatUntilReadCode(localVar, repeatUntilType, field.Name));
                break;

            case AlignmentNode alignmentNode:
                builder.AppendLine(GenerateAlignmentCode(alignmentNode));
                break;

            case InlineSchemaTypeNode inlineSchema:
                builder.AppendLine(GenerateInlineSchemaReadCode(localVar, field.Name, inlineSchema));
                break;

            default:
                builder.AppendLine($"// TODO: Unsupported type annotation: {typeAnnotation.GetType().Name}");
                if (field.Name != "_")
                {
                    var clrType = GetClrTypeName(typeAnnotation);
                    builder.AppendLine($"var {localVar} = default({clrType})!;");
                }

                break;
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Generates code to read a primitive type.
    /// </summary>
    private string GeneratePrimitiveReadCode(string localVar, PrimitiveTypeNode primitiveType)
    {
        var readMethod = GetPrimitiveReadMethod(primitiveType);
        return $"var {localVar} = {readMethod}(data);";
    }

    /// <summary>
    ///     Gets the appropriate read method name for a primitive type.
    /// </summary>
    private static string GetPrimitiveReadMethod(PrimitiveTypeNode primitiveType)
    {
        return primitiveType.TypeName switch
        {
            PrimitiveTypeName.Byte => "ReadByte",
            PrimitiveTypeName.SByte => "ReadSByte",
            PrimitiveTypeName.Short => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadInt16LE"
                : "ReadInt16BE",
            PrimitiveTypeName.UShort => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadUInt16LE"
                : "ReadUInt16BE",
            PrimitiveTypeName.Int => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadInt32LE"
                : "ReadInt32BE",
            PrimitiveTypeName.UInt => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadUInt32LE"
                : "ReadUInt32BE",
            PrimitiveTypeName.Long => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadInt64LE"
                : "ReadInt64BE",
            PrimitiveTypeName.ULong => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadUInt64LE"
                : "ReadUInt64BE",
            PrimitiveTypeName.Float => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadSingleLE"
                : "ReadSingleBE",
            PrimitiveTypeName.Double => primitiveType.Endianness == Endianness.LittleEndian
                ? "ReadDoubleLE"
                : "ReadDoubleBE",
            _ => throw new InvalidOperationException($"Unknown primitive type: {primitiveType.TypeName}")
        };
    }

    /// <summary>
    ///     Generates code to read a byte array.
    /// </summary>
    private string GenerateByteArrayReadCode(string localVar, ByteArrayTypeNode byteArrayType)
    {
        var sizeExpr = GenerateSizeExpression(byteArrayType.SizeExpression);
        return $"var {localVar} = ReadBytes(data, {sizeExpr});";
    }

    /// <summary>
    ///     Generates code to read a string, optionally parsing it with a text schema.
    /// </summary>
    private string GenerateStringReadCode(string localVar, StringTypeNode stringType)
    {
        var sizeExpr = GenerateSizeExpression(stringType.SizeExpression);
        var encodingExpr = GetEncodingExpression(stringType.Encoding);

        var builder = new StringBuilder();


        var rawStringVar = stringType.AsTextSchemaName != null ? $"{localVar}_raw" : localVar;


        if (stringType.Modifiers.HasFlag(StringModifier.NullTerm))
            builder.Append($"var {rawStringVar} = ReadNullTerminatedString(data, {sizeExpr}, {encodingExpr})");
        else
            builder.Append($"var {rawStringVar} = ReadString(data, {sizeExpr}, {encodingExpr})");


        if (stringType.Modifiers.HasFlag(StringModifier.Trim))
            builder.Append(".Trim()");
        else if (stringType.Modifiers.HasFlag(StringModifier.LTrim))
            builder.Append(".TrimStart()");
        else if (stringType.Modifiers.HasFlag(StringModifier.RTrim))
            builder.Append(".TrimEnd()");

        builder.Append(";");


        if (stringType.AsTextSchemaName != null)
        {
            builder.AppendLine();
            builder.AppendLine(
                $"                var {localVar}_textInterpreter = new {stringType.AsTextSchemaName}();");
            builder.Append($"                var {localVar} = {localVar}_textInterpreter.Parse({rawStringVar});");
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Gets the .NET Encoding expression for a StringEncoding value.
    ///     Returns a full expression that can be used in generated code.
    /// </summary>
    private static string GetEncodingExpression(StringEncoding encoding)
    {
        return encoding switch
        {
            StringEncoding.Utf8 => "System.Text.Encoding.UTF8",
            StringEncoding.Utf16Le => "System.Text.Encoding.Unicode",
            StringEncoding.Utf16Be => "System.Text.Encoding.BigEndianUnicode",
            StringEncoding.Ascii => "System.Text.Encoding.ASCII",
            StringEncoding.Latin1 => "System.Text.Encoding.Latin1",
            StringEncoding.Ebcdic => "System.Text.Encoding.GetEncoding(37)",
            _ => "System.Text.Encoding.UTF8"
        };
    }

    /// <summary>
    ///     Generates code to read bit fields.
    /// </summary>
    private string GenerateBitsReadCode(string localVar, BitsTypeNode bitsType)
    {
        var bitCount = bitsType.BitCount;
        var clrType = bitCount switch
        {
            <= 8 => "byte",
            <= 16 => "ushort",
            <= 32 => "uint",
            _ => "ulong"
        };
        return $"var {localVar} = ({clrType})ReadBits(data, {bitCount});";
    }

    /// <summary>
    ///     Generates code to read a nested schema reference.
    ///     Handles both regular schema references and generic type parameter references.
    /// </summary>
    private string GenerateSchemaReferenceReadCode(string localVar, SchemaReferenceTypeNode schemaRef)
    {
        var typeName = schemaRef.FullTypeName;
        var tempInterpreter = $"_{localVar}_interpreter";
        var builder = new StringBuilder();
        builder.AppendLine($"var {tempInterpreter} = new {typeName}();");
        builder.AppendLine($"var {localVar} = {tempInterpreter}.InterpretAt(data, _parsePosition);");
        builder.Append($"_parsePosition = {tempInterpreter}.BytesConsumed;");
        return builder.ToString();
    }

    /// <summary>
    ///     Generates code to read an inline schema.
    /// </summary>
    private string GenerateInlineSchemaReadCode(string localVar, string fieldName, InlineSchemaTypeNode inlineSchema)
    {
        var inlineClassName = GetOrRegisterInlineSchemaClassName(fieldName, inlineSchema, null);
        var tempInterpreter = $"_{localVar}_interpreter";
        var builder = new StringBuilder();
        builder.AppendLine($"var {tempInterpreter} = new {inlineClassName}();");
        builder.AppendLine($"var {localVar} = {tempInterpreter}.InterpretAt(data, _parsePosition);");
        builder.Append($"_parsePosition = {tempInterpreter}.BytesConsumed;");
        return builder.ToString();
    }

    /// <summary>
    ///     Generates code to read an array of elements.
    /// </summary>
    private string GenerateArrayReadCode(string localVar, ArrayTypeNode arrayType)
    {
        var builder = new StringBuilder();
        var countExpr = GenerateSizeExpression(arrayType.SizeExpression);
        var elementTypeName = GetClrTypeName(arrayType.ElementType);
        var loopVar = $"_{localVar}_i";
        var tempVar = $"_{localVar}_list";

        builder.AppendLine($"var {tempVar} = new System.Collections.Generic.List<{elementTypeName}>();");
        builder.AppendLine($"for (int {loopVar} = 0; {loopVar} < {countExpr}; {loopVar}++)");
        builder.AppendLine("{");


        if (arrayType.ElementType is PrimitiveTypeNode primitiveElement)
        {
            var readMethod = GetPrimitiveReadMethod(primitiveElement);
            builder.AppendLine($"    {tempVar}.Add({readMethod}(data));");
        }
        else if (arrayType.ElementType is SchemaReferenceTypeNode schemaRefElement)
        {
            var typeName = schemaRefElement.FullTypeName;
            var tempInterpreter = $"_{localVar}_elemInterpreter";
            builder.AppendLine($"    var {tempInterpreter} = new {typeName}();");
            builder.AppendLine($"    var _elem = {tempInterpreter}.InterpretAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = {tempInterpreter}.BytesConsumed;");
            builder.AppendLine($"    {tempVar}.Add(_elem);");
        }
        else
        {
            builder.AppendLine($"    // TODO: Unsupported array element type: {arrayType.ElementType.GetType().Name}");
        }

        builder.AppendLine("}");
        builder.AppendLine($"var {localVar} = {tempVar}.ToArray();");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates code to read elements repeatedly until a condition is met.
    ///     Uses do-while semantics: at least one element is always attempted.
    /// </summary>
    private string GenerateRepeatUntilReadCode(string localVar, RepeatUntilTypeNode repeatUntilType, string fieldName)
    {
        var builder = new StringBuilder();
        var elementTypeName = GetClrTypeName(repeatUntilType.ElementType);
        var tempVar = $"_{localVar}_list";
        var lastElemVar = $"_{localVar}_lastElem";

        builder.AppendLine($"var {tempVar} = new System.Collections.Generic.List<{elementTypeName}>();");
        builder.AppendLine($"{elementTypeName} {lastElemVar};");
        builder.AppendLine("do");
        builder.AppendLine("{");


        if (repeatUntilType.ElementType is PrimitiveTypeNode primitiveElement)
        {
            var readMethod = GetPrimitiveReadMethod(primitiveElement);
            builder.AppendLine($"    {lastElemVar} = {readMethod}(data);");
            builder.AppendLine($"    {tempVar}.Add({lastElemVar});");
        }
        else if (repeatUntilType.ElementType is SchemaReferenceTypeNode schemaRefElement)
        {
            var typeName = schemaRefElement.FullTypeName;
            var tempInterpreter = $"_{localVar}_elemInterpreter";
            builder.AppendLine($"    var {tempInterpreter} = new {typeName}();");
            builder.AppendLine($"    {lastElemVar} = {tempInterpreter}.InterpretAt(data, _parsePosition);");
            builder.AppendLine($"    _parsePosition = {tempInterpreter}.BytesConsumed;");
            builder.AppendLine($"    {tempVar}.Add({lastElemVar});");
        }
        else
        {
            builder.AppendLine(
                $"    // TODO: Unsupported repeat until element type: {repeatUntilType.ElementType.GetType().Name}");
        }


        var conditionExpr = GenerateRepeatUntilCondition(repeatUntilType.Condition, fieldName, lastElemVar, tempVar);
        builder.AppendLine($"}} while (!({conditionExpr}));");

        builder.AppendLine($"var {localVar} = {tempVar}.ToArray();");

        return builder.ToString();
    }

    /// <summary>
    ///     Generates a condition expression for repeat until, handling FieldName[-1] references.
    /// </summary>
    private string GenerateRepeatUntilCondition(Node condition, string fieldName, string lastElemVar, string listVar)
    {
        return GenerateRepeatUntilConditionInner(condition, fieldName, lastElemVar, listVar);
    }

    /// <summary>
    ///     Inner recursive method for generating repeat until conditions.
    /// </summary>
    private string GenerateRepeatUntilConditionInner(Node condition, string fieldName, string lastElemVar,
        string listVar)
    {
        return condition switch
        {
            EqualityNode eq =>
                $"({GenerateRepeatUntilConditionInner(eq.Left, fieldName, lastElemVar, listVar)} == {GenerateRepeatUntilConditionInner(eq.Right, fieldName, lastElemVar, listVar)})",
            DiffNode diff =>
                $"({GenerateRepeatUntilConditionInner(diff.Left, fieldName, lastElemVar, listVar)} != {GenerateRepeatUntilConditionInner(diff.Right, fieldName, lastElemVar, listVar)})",
            GreaterNode gt =>
                $"({GenerateRepeatUntilConditionInner(gt.Left, fieldName, lastElemVar, listVar)} > {GenerateRepeatUntilConditionInner(gt.Right, fieldName, lastElemVar, listVar)})",
            GreaterOrEqualNode gte =>
                $"({GenerateRepeatUntilConditionInner(gte.Left, fieldName, lastElemVar, listVar)} >= {GenerateRepeatUntilConditionInner(gte.Right, fieldName, lastElemVar, listVar)})",
            LessNode lt =>
                $"({GenerateRepeatUntilConditionInner(lt.Left, fieldName, lastElemVar, listVar)} < {GenerateRepeatUntilConditionInner(lt.Right, fieldName, lastElemVar, listVar)})",
            LessOrEqualNode lte =>
                $"({GenerateRepeatUntilConditionInner(lte.Left, fieldName, lastElemVar, listVar)} <= {GenerateRepeatUntilConditionInner(lte.Right, fieldName, lastElemVar, listVar)})",
            AndNode andNode =>
                $"({GenerateRepeatUntilConditionInner(andNode.Left, fieldName, lastElemVar, listVar)} && {GenerateRepeatUntilConditionInner(andNode.Right, fieldName, lastElemVar, listVar)})",
            OrNode orNode =>
                $"({GenerateRepeatUntilConditionInner(orNode.Left, fieldName, lastElemVar, listVar)} || {GenerateRepeatUntilConditionInner(orNode.Right, fieldName, lastElemVar, listVar)})",
            IntegerNode intNode => intNode.ObjValue?.ToString() ?? "0",
            HexIntegerNode hexNode => hexNode.ObjValue?.ToString() ?? "0",
            DecimalNode decNode => decNode.ObjValue?.ToString() ?? "0",

            AccessColumnNode acNode when string.Equals(acNode.Name, fieldName, StringComparison.OrdinalIgnoreCase) =>
                lastElemVar,
            AccessColumnNode acNode => GetLocalVarName(acNode.Name),
            IdentifierNode idNode when string.Equals(idNode.Name, fieldName, StringComparison.OrdinalIgnoreCase) =>
                lastElemVar,
            IdentifierNode idNode => GetLocalVarName(idNode.Name),

            DotNode dotNode when dotNode.Root is AccessColumnNode rootCol &&
                                 string.Equals(rootCol.Name, fieldName, StringComparison.OrdinalIgnoreCase) =>
                $"{lastElemVar}.{GetPropertyNameFromExpression(dotNode.Expression)}",
            DotNode dotNode when dotNode.Root is IdentifierNode rootId &&
                                 string.Equals(rootId.Name, fieldName, StringComparison.OrdinalIgnoreCase) =>
                $"{lastElemVar}.{GetPropertyNameFromExpression(dotNode.Expression)}",

            DotNode dotNode =>
                $"{GenerateRepeatUntilConditionInner(dotNode.Root, fieldName, lastElemVar, listVar)}.{GetPropertyNameFromExpression(dotNode.Expression)}",

            AddNode add =>
                $"({GenerateRepeatUntilConditionInner(add.Left, fieldName, lastElemVar, listVar)} + {GenerateRepeatUntilConditionInner(add.Right, fieldName, lastElemVar, listVar)})",
            HyphenNode hyp =>
                $"({GenerateRepeatUntilConditionInner(hyp.Left, fieldName, lastElemVar, listVar)} - {GenerateRepeatUntilConditionInner(hyp.Right, fieldName, lastElemVar, listVar)})",
            StarNode star =>
                $"({GenerateRepeatUntilConditionInner(star.Left, fieldName, lastElemVar, listVar)} * {GenerateRepeatUntilConditionInner(star.Right, fieldName, lastElemVar, listVar)})",
            FSlashNode slash =>
                $"({GenerateRepeatUntilConditionInner(slash.Left, fieldName, lastElemVar, listVar)} / {GenerateRepeatUntilConditionInner(slash.Right, fieldName, lastElemVar, listVar)})",
            ModuloNode mod =>
                $"({GenerateRepeatUntilConditionInner(mod.Left, fieldName, lastElemVar, listVar)} % {GenerateRepeatUntilConditionInner(mod.Right, fieldName, lastElemVar, listVar)})",
            _ => condition.ToString() ?? "false"
        };
    }

    /// <summary>
    ///     Generates alignment code.
    /// </summary>
    private string GenerateAlignmentCode(AlignmentNode alignmentNode)
    {
        var bits = alignmentNode.AlignmentBits;
        return $"AlignToBits(data, {bits});";
    }

    /// <summary>
    ///     Generates a size expression (constant or field reference).
    /// </summary>
    private string GenerateSizeExpression(Node sizeExpression)
    {
        if (sizeExpression is IntegerNode intNode) return intNode.ObjValue.ToString() ?? "0";

        if (sizeExpression is AccessColumnNode accessNode)
        {
            var localVar = GetLocalVarName(accessNode.Name);
            return $"(int){localVar}";
        }

        if (sizeExpression is IdentifierNode identifierNode)
        {
            var localVar = GetLocalVarName(identifierNode.Name);
            return $"(int){localVar}";
        }


        if (sizeExpression is AddNode addNode)
        {
            var left = GenerateSizeExpression(addNode.Left);
            var right = GenerateSizeExpression(addNode.Right);
            return $"({left} + {right})";
        }

        if (sizeExpression is HyphenNode hyphenNode)
        {
            var left = GenerateSizeExpression(hyphenNode.Left);
            var right = GenerateSizeExpression(hyphenNode.Right);
            return $"({left} - {right})";
        }

        if (sizeExpression is StarNode starNode)
        {
            var left = GenerateSizeExpression(starNode.Left);
            var right = GenerateSizeExpression(starNode.Right);
            return $"({left} * {right})";
        }

        if (sizeExpression is FSlashNode divNode)
        {
            var left = GenerateSizeExpression(divNode.Left);
            var right = GenerateSizeExpression(divNode.Right);
            return $"({left} / {right})";
        }

        if (sizeExpression is ModuloNode modNode)
        {
            var left = GenerateSizeExpression(modNode.Left);
            var right = GenerateSizeExpression(modNode.Right);
            return $"({left} % {right})";
        }


        return sizeExpression.ToString() ?? "0";
    }

    /// <summary>
    ///     Gets the CLR type name for a type annotation.
    /// </summary>
    private static string GetClrTypeName(TypeAnnotationNode typeAnnotation)
    {
        return typeAnnotation switch
        {
            PrimitiveTypeNode p => p.TypeName switch
            {
                PrimitiveTypeName.Byte => "byte",
                PrimitiveTypeName.SByte => "sbyte",
                PrimitiveTypeName.Short => "short",
                PrimitiveTypeName.UShort => "ushort",
                PrimitiveTypeName.Int => "int",
                PrimitiveTypeName.UInt => "uint",
                PrimitiveTypeName.Long => "long",
                PrimitiveTypeName.ULong => "ulong",
                PrimitiveTypeName.Float => "float",
                PrimitiveTypeName.Double => "double",
                _ => "object"
            },
            ByteArrayTypeNode => "byte[]",
            StringTypeNode s => s.AsTextSchemaName ?? "string",
            BitsTypeNode b => b.BitCount switch
            {
                <= 8 => "byte",
                <= 16 => "ushort",
                <= 32 => "uint",
                _ => "ulong"
            },
            SchemaReferenceTypeNode s => s.FullTypeName,
            ArrayTypeNode a => $"{GetClrTypeName(a.ElementType)}[]",
            RepeatUntilTypeNode r => $"{GetClrTypeName(r.ElementType)}[]",
            InlineSchemaTypeNode => "object",
            _ => "object"
        };
    }

    /// <summary>
    ///     Gets the CLR type name for a schema field (parsed or computed).
    /// </summary>
    private static string GetClrTypeNameForField(SchemaFieldNode field)
    {
        return field switch
        {
            FieldDefinitionNode parsedField => GetClrTypeName(parsedField.TypeAnnotation),
            ComputedFieldNode computedField => InferComputedFieldTypeNameStatic(computedField.Expression),
            _ => "object"
        };
    }

    /// <summary>
    ///     Gets the CLR type name for a FieldDefinitionNode, handling inline schemas.
    /// </summary>
    private string GetClrTypeNameForFieldDefinition(FieldDefinitionNode field)
    {
        if (field.TypeAnnotation is InlineSchemaTypeNode inlineSchema)
            return GetOrRegisterInlineSchemaClassName(field.Name, inlineSchema, null);
        return GetClrTypeName(field.TypeAnnotation);
    }

    /// <summary>
    ///     Gets the CLR type name for a schema field with context.
    ///     For inline schemas, registers the schema for nested class generation.
    /// </summary>
    private string GetClrTypeNameForFieldWithContext(SchemaFieldNode field, List<SchemaFieldNode> contextFields)
    {
        return field switch
        {
            FieldDefinitionNode parsedField when parsedField.TypeAnnotation is InlineSchemaTypeNode inlineSchema
                => GetOrRegisterInlineSchemaClassName(parsedField.Name, inlineSchema, null),
            FieldDefinitionNode parsedField => GetClrTypeName(parsedField.TypeAnnotation),
            ComputedFieldNode computedField => InferComputedFieldTypeName(computedField.Expression, contextFields),
            _ => "object"
        };
    }

    /// <summary>
    ///     Gets or registers an inline schema class name, tracking it for nested class generation.
    /// </summary>
    private string GetOrRegisterInlineSchemaClassName(string fieldName, InlineSchemaTypeNode inlineSchema,
        string? parentPrefix)
    {
        var className = $"Inline_{fieldName}";


        var existing = _inlineSchemas.FirstOrDefault(x => x.ClassName == className);
        if (existing.Schema == null) _inlineSchemas.Add((className, inlineSchema, parentPrefix));

        return className;
    }

    /// <summary>
    ///     Static version of type inference for computed fields (without context).
    /// </summary>
    private static string InferComputedFieldTypeNameStatic(Node expression)
    {
        if (expression is EqualityNode or DiffNode or GreaterNode or GreaterOrEqualNode
            or LessNode or LessOrEqualNode or AndNode or OrNode)
            return "bool";


        if (expression is WordNode)
            return "string";


        if (expression is AccessMethodNode methodNode)
            if (methodNode.Name.Equals("ToString", StringComparison.OrdinalIgnoreCase))
                return "string";


        if (expression is AddNode addNode)
        {
            var leftType = InferComputedFieldTypeNameStatic(addNode.Left);
            var rightType = InferComputedFieldTypeNameStatic(addNode.Right);
            if (leftType == "string" || rightType == "string")
                return "string";
        }


        if (expression is AddNode or HyphenNode or StarNode or FSlashNode or ModuloNode) return "int";

        return "object";
    }

    /// <summary>
    ///     Infers the CLR type name from a computed field expression.
    /// </summary>
    private string InferComputedFieldTypeName(Node expression, List<SchemaFieldNode>? contextFields = null)
    {
        if (expression is EqualityNode or DiffNode or GreaterNode or GreaterOrEqualNode
            or LessNode or LessOrEqualNode or AndNode or OrNode)
            return "bool";


        if (expression is AddNode addNode)
        {
            var leftType = InferExpressionType(addNode.Left, contextFields);
            var rightType = InferExpressionType(addNode.Right, contextFields);
            if (leftType == "string" || rightType == "string")
                return "string";
        }


        if (expression is BinaryNode binaryNode && contextFields != null)
        {
            var leftType = InferOperandType(binaryNode.Left, contextFields);
            var rightType = InferOperandType(binaryNode.Right, contextFields);


            return GetWiderArithmeticType(leftType, rightType);
        }


        var returnType = expression.ReturnType;
        if (returnType != null && returnType != typeof(object) && returnType != typeof(void))
            return MapClrTypeName(returnType);


        if (expression is AddNode or HyphenNode or StarNode or FSlashNode or ModuloNode
            or BitwiseAndNode or BitwiseOrNode or BitwiseXorNode or LeftShiftNode or RightShiftNode)
            return "int";


        if (expression is WordNode)
            return "string";


        if (expression is AccessMethodNode methodNode)
            if (methodNode.Name.Equals("ToString", StringComparison.OrdinalIgnoreCase))
                return "string";


        return "object";
    }

    /// <summary>
    ///     Infers the type of an expression node.
    /// </summary>
    private string InferExpressionType(Node node, List<SchemaFieldNode>? contextFields)
    {
        return node switch
        {
            WordNode => "string",
            AccessMethodNode method when method.Name.Equals("ToString", StringComparison.OrdinalIgnoreCase) => "string",
            IntegerNode or HexIntegerNode => "int",
            DecimalNode => "decimal",
            IdentifierNode id => contextFields?.FirstOrDefault(f =>
                f.Name.Equals(id.Name, StringComparison.OrdinalIgnoreCase)) is { } field
                ? GetClrTypeNameForField(field)
                : "object",
            AddNode add => InferExpressionType(add.Left, contextFields) == "string" ||
                           InferExpressionType(add.Right, contextFields) == "string"
                ? "string"
                : "int",
            _ => "object"
        };
    }

    /// <summary>
    ///     Infers the type of an operand node from field context.
    /// </summary>
    private string InferOperandType(Node operand, List<SchemaFieldNode> contextFields)
    {
        if (operand is BinaryNode binaryOp) return InferComputedFieldTypeName(binaryOp, contextFields);


        if (operand is IdentifierNode identifier)
        {
            var field = contextFields.FirstOrDefault(f =>
                f.Name.Equals(identifier.Name, StringComparison.OrdinalIgnoreCase));

            if (field != null) return GetClrTypeNameForField(field);
        }


        if (operand is IntegerNode or HexIntegerNode) return "int";

        return "object";
    }

    /// <summary>
    ///     Gets the wider of two arithmetic types for expression result inference.
    /// </summary>
    private static string GetWiderArithmeticType(string left, string right)
    {
        var typeOrder = new[] { "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double" };
        var leftIndex = Array.IndexOf(typeOrder, left);
        var rightIndex = Array.IndexOf(typeOrder, right);

        if (leftIndex < 0 && rightIndex < 0) return "int";
        if (leftIndex < 0) return right;
        if (rightIndex < 0) return left;

        return leftIndex > rightIndex ? left : right;
    }

    /// <summary>
    ///     Maps a CLR Type to its C# type name.
    /// </summary>
    private static string MapClrTypeName(Type type)
    {
        return type.Name.ToLowerInvariant() switch
        {
            "byte" => "byte",
            "sbyte" => "sbyte",
            "int16" => "short",
            "uint16" => "ushort",
            "int32" => "int",
            "uint32" => "uint",
            "int64" => "long",
            "uint64" => "ulong",
            "single" => "float",
            "double" => "double",
            "boolean" => "bool",
            "string" => "string",
            _ => "object"
        };
    }

    /// <summary>
    ///     Generates code for a computed field (expression-based, no bytes consumed).
    /// </summary>
    private string GenerateComputedFieldCode(ComputedFieldNode field, List<SchemaFieldNode>? contextFields = null)
    {
        var builder = new StringBuilder();
        var localVar = GetLocalVarName(field.Name);
        var expression = GenerateConditionExpression(field.Expression);
        var typeName = InferComputedFieldTypeName(field.Expression, contextFields);

        builder.AppendLine($"var {localVar} = ({typeName})({expression});");

        return builder.ToString();
    }

    /// <summary>
    ///     Gets a local variable name from a field name.
    /// </summary>
    private static string GetLocalVarName(string fieldName)
    {
        if (fieldName == "_") return "_discard";
        return $"_{char.ToLowerInvariant(fieldName[0])}{fieldName.Substring(1)}";
    }

    /// <summary>
    ///     Indents a block of code.
    /// </summary>
    private static string Indent(string code, int levels)
    {
        var indent = new string(' ', levels * 4);
        var lines = code.Split('\n');
        var result = new StringBuilder();
        foreach (var line in lines)
            if (string.IsNullOrWhiteSpace(line))
                result.AppendLine();
            else
                result.AppendLine(indent + line.TrimEnd('\r'));
        return result.ToString().TrimEnd();
    }

    /// <summary>
    ///     Checks if a CLR type name is a reference type (can be null without '?').
    /// </summary>
    private static bool IsReferenceType(string clrTypeName)
    {
        return clrTypeName switch
        {
            "string" => true,
            "object" => true,
            _ when clrTypeName.EndsWith("[]") => true,
            _ => false
        };
    }

    /// <summary>
    ///     Checks if a type name is a type parameter of the current generic schema.
    /// </summary>
    private bool IsTypeParameter(string typeName)
    {
        return _currentTypeParameters.Contains(typeName, StringComparer.Ordinal);
    }

    /// <summary>
    ///     Generates a condition expression from an AST node (for when clause).
    /// </summary>
    private string GenerateConditionExpression(Node condition)
    {
        return condition switch
        {
            EqualityNode eq => $"({GenerateConditionExpression(eq.Left)} == {GenerateConditionExpression(eq.Right)})",
            DiffNode diff => $"({GenerateConditionExpression(diff.Left)} != {GenerateConditionExpression(diff.Right)})",
            GreaterNode gt => $"({GenerateConditionExpression(gt.Left)} > {GenerateConditionExpression(gt.Right)})",
            GreaterOrEqualNode gte =>
                $"({GenerateConditionExpression(gte.Left)} >= {GenerateConditionExpression(gte.Right)})",
            LessNode lt => $"({GenerateConditionExpression(lt.Left)} < {GenerateConditionExpression(lt.Right)})",
            LessOrEqualNode lte =>
                $"({GenerateConditionExpression(lte.Left)} <= {GenerateConditionExpression(lte.Right)})",
            AndNode andNode =>
                $"({GenerateConditionExpression(andNode.Left)} && {GenerateConditionExpression(andNode.Right)})",
            OrNode orNode =>
                $"({GenerateConditionExpression(orNode.Left)} || {GenerateConditionExpression(orNode.Right)})",
            IntegerNode intNode => intNode.ObjValue?.ToString() ?? "0",
            DecimalNode decNode => decNode.ObjValue?.ToString() ?? "0",
            WordNode wordNode => $"\"{EscapeString(wordNode.Value)}\"",
            AccessColumnNode acNode => GetLocalVarName(acNode.Name),
            IdentifierNode idNode => GetLocalVarName(idNode.Name),
            AccessMethodNode methodNode => GenerateMethodCallExpression(methodNode),
            AddNode add => $"({GenerateConditionExpression(add.Left)} + {GenerateConditionExpression(add.Right)})",
            HyphenNode hyp => $"({GenerateConditionExpression(hyp.Left)} - {GenerateConditionExpression(hyp.Right)})",
            StarNode star => $"({GenerateConditionExpression(star.Left)} * {GenerateConditionExpression(star.Right)})",
            FSlashNode slash =>
                $"({GenerateConditionExpression(slash.Left)} / {GenerateConditionExpression(slash.Right)})",
            ModuloNode mod => $"({GenerateConditionExpression(mod.Left)} % {GenerateConditionExpression(mod.Right)})",
            HexIntegerNode hexNode => hexNode.ObjValue?.ToString() ?? "0",

            BitwiseAndNode bitwiseAnd =>
                $"({GenerateConditionExpression(bitwiseAnd.Left)} & {GenerateConditionExpression(bitwiseAnd.Right)})",
            BitwiseOrNode bitwiseOr =>
                $"({GenerateConditionExpression(bitwiseOr.Left)} | {GenerateConditionExpression(bitwiseOr.Right)})",
            BitwiseXorNode bitwiseXor =>
                $"({GenerateConditionExpression(bitwiseXor.Left)} ^ {GenerateConditionExpression(bitwiseXor.Right)})",
            LeftShiftNode leftShift =>
                $"({GenerateConditionExpression(leftShift.Left)} << {GenerateConditionExpression(leftShift.Right)})",
            RightShiftNode rightShift =>
                $"({GenerateConditionExpression(rightShift.Left)} >> {GenerateConditionExpression(rightShift.Right)})",
            _ => condition.ToString() ?? "false"
        };
    }

    /// <summary>
    ///     Generates a method call expression (e.g., ToString(field)).
    /// </summary>
    private string GenerateMethodCallExpression(AccessMethodNode methodNode)
    {
        var methodName = methodNode.Name;
        var args = methodNode.Arguments?.Args ?? Array.Empty<Node>();
        var argExpressions = args.Select(GenerateConditionExpression).ToList();


        return methodName.ToLowerInvariant() switch
        {
            "tostring" when argExpressions.Count == 1 => $"{argExpressions[0]}.ToString()",
            "tostring" when argExpressions.Count == 0 => ".ToString()",
            _ => $"{methodName}({string.Join(", ", argExpressions)})"
        };
    }

    /// <summary>
    ///     Escapes a string for use in C# code.
    /// </summary>
    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    /// <summary>
    ///     Extracts a property name from an expression node (typically IdentifierNode from a DotNode).
    /// </summary>
    private static string GetPropertyNameFromExpression(Node expression)
    {
        return expression switch
        {
            AccessColumnNode acNode => acNode.Name,
            IdentifierNode idNode => idNode.Name,
            _ => expression.ToString() ?? "Unknown"
        };
    }
}
